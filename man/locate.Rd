% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/locate.R
\name{locate}
\alias{locate}
\alias{cached_locate}
\alias{locate_next}
\title{Locate all occurrences of a vector (needle) within another vector of values (haystack)}
\usage{
locate(needle, haystack, alignment = NA_integer_)

cached_locate(needle, haystack, alignment = NA_integer_)

locate_next(needle, haystack, start = 1L, alignment = NA)
}
\arguments{
\item{needle}{vector of values}

\item{haystack}{vector of values}

\item{alignment}{search must start at a multiple of this index location (+1). Useful for
byte-aligned searches of bit vectors i.e. \code{alignment=8}. Default: NA (no alignment).}

\item{start}{lowest index to accept}
}
\value{
Indices of the start of all occurrences of needle in haystack, or NA if no matches found.
}
\description{
This will return all starting locations of the needle found within the haystack -
even overlapping ones.
}
\details{
The routine is pretty relaxed about types so you can search for an integer vector
within a character vector if you so choose.

Supported types:
\itemize{
  \item{all built-in atomic types in R i.e. integer, numeric, real, character,
        complex, raw}{}
  \item{\code{bit} type from the \code{bit} package}{ - Note: in order to
        search for the matches, 'bit' objects are basically extracted to
        their equivalent logical vector causing higher memory usage
        and negating any memory savings of using 'bit'.}
}

\code{locate} is the core location function. There is no cacheing, so identical searches
are started from scratch each time.

\code{cached_locate} is a memoised version of \code{locate}. Because calling
\code{locate} can be quite an expensive operation, searches for a given
sequence in a haystack are cached to save time on subsequent calls.

\code{locate_next} gives the first index on, or after, the given \code{start} index.

Adapted from code originally written by carroll_jono - https://twitter.com/carroll_jono
}
